---
title: 'Birthday data case study: Diagnosis of the HSGP approximation'
date: "`r format(Sys.Date())`."
output:
  html_document:
    theme: readable
    toc: yes
    toc_depth: 4
    toc_float: 
      collapsed: true
    code_download: yes
    df_print: kable
---

<style type="text/css">
body, td{ font-size: 16px; }
code.r{ font-size: 12px; }
pre{ font-size: 12px }
</style>


```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment="")
```

## Load packages

```{r message=FALSE, warn=FALSE, eval=TRUE}
library(rstan)
library(cmdstanr)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = FALSE)
library(posterior)
library(bayesplot)
library(ggplot2)
library(loo)
library(latex2exp)
# library(reshape2)
# library(plyr)
```

## Data

```{r message=FALSE, warn=FALSE}
data <- read.csv(file="births_usa_1969.csv")
str(data)
```

```{r message=TRUE, warn=TRUE, fig.height=5, fig.width=8, echo=FALSE}
par(mai=c(1.02,1.2,0.3,0.42))

ind <- data$id
births <- data$births
labels_at = aggregate(data, by=list(data$year), FUN=min)$id

plot(ind, births[ind], type="p", pch=20, bg=grey(0.4), cex=0.6, col=grey(0.5), xlab="", ylab="", lwd=1, mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.2, cex.lab=1.2, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")
axis(1, at = labels_at, c("1969","1970","1971","1972","1973","1974","1975","1976","1977","1978","1979","1980","1981","1982","1983","1984","1985","1986","1987","1988"), lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.2, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.2, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Year", mgp=c(2.2, 1, 0), cex.lab=1.2, las=1)
title(ylab="Births", mgp=c(3.7, 0.7, 0), cex.lab=1.2, las=1)
legend("topleft",inset=c(0.22,0.02),legend=c("Observations"), col=grey(0.4), lty=NA, pch=20, lwd=1, cex=1, xpd=TRUE, bty="n", x.intersp=0.1, text.font=1)
```

Input vector

```{r message=FALSE, warn=FALSE}
x <- scale(data$id[], center=TRUE, scale=TRUE)
```

Output vector

```{r message=FALSE, warn=FALSE}
y <- scale(data$births[], center=TRUE, scale=TRUE)
```

Standard deviation and mean of the output

```{r message=FALSE, warn=FALSE}
std_y <- attr(y,"scaled:scale")
m_y <- attr(y,"scaled:center")
```

Standard deviation of the input

```{r message=FALSE, warn=FALSE}
std_x <- attr(x,"scaled:scale")
std_x
```

Year and week periods

```{r message=FALSE, warn=FALSE}
period_year <- 365.25/std_x
period_week <- 7/std_x
```

`Day of the year2` is a variable that indicates the correspondence between all the days with the days of a leap-year

```{r message=FALSE, warn=FALSE}
day_of_year2 <- data$day_of_year2
```

Half range of the input domain

```{r message=FALSE, warn=FALSE}
S <- (max(x) - min(x))/2
S
```

## Relationships among $m$, $l$ and $c$

1. Relationship among the number of basis functions $m$, the lengthscale $l$ and the boundary factor $c$ for a **squared exponential kernel**:

$$ m= 1.73 \, \frac{c}{\left(\frac{l}{S}\right)^{1.05}}, \;\;\; {\small\text{or equivalently,}} \;\;\; \frac{l}{S}= 1.68 \, \frac{c^{0.95}}{m^{0.95}}$$

with $c \, \geq \, 0.97 + 1.45 \, \frac{l}{S}$, and $S$ being the half range of the input domain.

2. Relationship between $m$ and $l$ for a **squared exponential periodic kernel**:

$$m= 3.31 \, \frac{1}{l^{1.05}}, \;\;\; {\small\text{or equivalently,}} \;\;\; l= 3.12 \, \frac{1}{m^{0.95}}$$

## Model 

Let $y_t$ denote the number of births on the $t$'th day, 

\begin{align*}
&y_{t} \sim \text{Normal}(\mu(t),\sigma^2), \\
&\mu(t) = f_1(t) + f_2(t) + f_3(t) + f_4(t)
\end{align*}

The component $f_1(t)$ represents the long-term trends modeled by a GP with squared exponential covariance function,

\begin{equation*}
f_1(t) \sim \text{GP}(0,k_1), \hspace{5mm} k_1(t,t') = \alpha_1 \exp\!\!\left(\!-\frac{1}{2} \frac{(t-t')^2}{\ell_1^2}\right) 
\end{equation*}

The component $f_2(t)$ represents the yearly smooth seasonal pattern, using a periodic squared exponential covariance function (with period 365.25 to match the average length of the year) in a GP model,

\begin{align*}
&f_2(t) \sim \text{GP}(0,k_2), \\
&k_2(t,t') = \alpha_2 \exp\!\!\left(\!-\frac{2\,\sin^{\!2}\!(\pi(t-t')/365.25}{\ell_2^2}\right)
\end{align*}

The component $f_3(t)$ represents the weekly smooth pattern using a periodic squared exponential covariance function (with period 7 of length of the week) in a GP model,

\begin{align*}
&f_3(t) \sim \text{GP}(0,k_3), \\
&k_3(t,t') = \alpha_3 \exp\!\!\left(\!-\frac{2\,\sin^{\!2}\!(\pi(t-t')/7}{\ell_3^2}\right)
\end{align*}

The component $f_4(t)$ represents the special days effects modeled as t-student distribution:

\begin{align*}
&f_4(t) \sim \text{t-student}(0,\alpha_4^2), \; {\small\text{with 1 degree of freedom}},\\
&\alpha_4 \sim \text{Normal}(0,0.1)
\end{align*}

**Model in Stan code**

```
//saved in 'stancode_def.stan'
functions {
  vector diagSPD_EQ(real gpscale, real lscale, real L, int M) {
    return sqrt((gpscale^2) * sqrt(2*pi()) * lscale * exp(-0.5*(lscale*pi()/2/L)^2 * linspaced_vector(M, 1, M)^2));
  }
  vector diagSPD_periodic(real gpscale, real lscale, int M) {
    real a = 1/lscale^2;
    int one_to_M[M];
    for (m in 1:M) one_to_M[m] = m;
    vector[M] q = sqrt(gpscale^2 * 2 / exp(a) * to_vector(modified_bessel_first_kind(one_to_M, a)));
    return append_row(q,q);
  }
  matrix PHI_EQ(int N, int M, real L, vector x) {
     matrix[N,M] PHI = sin(diag_post_multiply(rep_matrix(pi()/(2*L) * (x+L), M), linspaced_vector(M, 1, M)))/sqrt(L);
     for (m in 1:M)
       PHI[,m] = PHI[,m] - mean(PHI[,m]);
     return PHI;
  }
  matrix PHI_periodic(int N, int M, real w0, vector x) {
    matrix[N,M] mw0x = diag_post_multiply(rep_matrix(w0*x, M), linspaced_vector(M, 1, M));
    matrix[N,M] PHI = append_col(cos(mw0x), sin(mw0x));
    for (m in 1:M)
      PHI[,m] = PHI[,m] - mean(PHI[,m]);
    return PHI;
  }
}
data {
    real c_f1;                  //boundary value for function 1
    int<lower=1> M_f1;          //num basis functions for function 1
    int<lower=-1> J_f2;         //num cosine and sinu functions for function 3
    int<lower=-1> J_f3;         //num cosine and sinu functions for function 4
    int<lower=1> N;             //num observations
    vector[N] x;                //input vector
    vector[N] y;                //target vector
    real period_year;           //period of the year
    real period_week;           //period of the week
    int day_of_year2[N];        //day of the year inside a leap-year
}
transformed data {
    real L_f1= c_f1*max(fabs(x));
    //Basis functions for f1, f2 and f3
    matrix[N,M_f1] PHI_f1 = PHI_EQ(N, M_f1, L_f1, x);
    matrix[N,2*J_f2] PHI_f2 = PHI_periodic(N, J_f2, 2*pi()/period_year, x);
    matrix[N,2*J_f3] PHI_f3 = PHI_periodic(N, J_f3, 2*pi()/period_week, x);
}
parameters {
    vector[N] f;
    real intercept;
    //variables for the basis function models
    vector[M_f1] beta_f1;
    vector[2*J_f2] beta_f2;
    vector[2*J_f3] beta_f3;
    //hyperparameters
    vector<lower=0>[3] lscale;
    vector<lower=0>[3] gpscale;
    real<lower=0> noise;
    //
    //t-student prior for special days effects
    vector[366] f4;
    real<lower=0> sigma_f4;
}
transformed parameters{
    vector[N] f1;
    vector[N] f2;
    vector[N] f3;
    {
    vector[M_f1] diagSPD_f1 = diagSPD_EQ(gpscale[1], lscale[1], L_f1, M_f1);
    vector[2*J_f2] diagSPD_f2 = diagSPD_periodic(gpscale[2], lscale[2], J_f2);
    vector[2*J_f3] diagSPD_f3 = diagSPD_periodic(gpscale[3], lscale[3], J_f3);
    //
    vector[M_f1] SPD_beta_f1 = diagSPD_f1 .* beta_f1;
    vector[2*J_f2] SPD_beta_f2 = diagSPD_f2 .* beta_f2;
    vector[2*J_f3] SPD_beta_f3 = diagSPD_f3 .* beta_f3;
    //
    f1 = PHI_f1[,] * SPD_beta_f1;
    f2 = PHI_f2[,] * SPD_beta_f2;
    f3 = PHI_f3[,] * SPD_beta_f3;
    }
}
model{
    intercept ~ normal(0,1);
    beta_f1 ~ normal(0,1);
    beta_f2 ~ normal(0,1);
    beta_f3 ~ normal(0,1);
    //
    lscale ~ normal(0,2);           //GP lengthscales
    gpscale ~ normal(0,10);         //GP magnitudes
    noise ~ normal(0,1);            //model noise
    //
    //t-student prior for special days effects
    f4 ~ student_t(1, 0, sigma_f4);
    sigma_f4 ~ normal(0, 0.1);
    //
    f= intercept + f1 + f2 + f3 + f4[day_of_year2];
    target += normal_lpdf(y | f, noise);
}
generated quantities{
  vector[N] y_rep;
  vector[N] log_lik;
  for(n in 1:N){
    y_rep[n] = normal_rng(f[n], noise);
    log_lik[n] = normal_lpdf(y[n] | f[n], noise);
  }
}
```

## User-guide for diagnosis

**Assumption of the diagnosis tool:**

- Under inaccurate HSGP approximation, the estimated lengthscale $\hat{l}$ is (always) smaller than the true lengthscale $l$.

**User-guide with the steps to perform diagnosis:**

0. Make a first guess of the lengthscale $l^1$ of the function to be learned.

*Iteration 1*

1. Obtain the minimum valid boundary factor $c^1$ determined by the first guess $l^1$, by using the functional relationship $\, c^1 \, \geq \, 0.97 + 1.45 \, \frac{l^1}{S}$, where $S$ represents the half range of the input domain.

2. Obtain the mimimum valid number of basis functions $m^1$ determined by $l^1$ and $c^1$, by using the functional relationship $\, m^1= 1.73 \, \frac{c^1}{\left(\frac{l^1}{S}\right)^{1.05}}$. Notice that $l^1$ can also be read as the minimum lengthscale that can be accurately fitted determined by $m^1$ and $c^1$ $\left(\frac{l^1}{S}= 1.68 \, \frac{(c^1)^{0.95}}{(m^1)^{0.95}}\right)$.

3. Fit the HSGP model and assess residuals: check any residual trends, compute rmse (Root mean square error), $R^2$ (Coefficient of variation) and elpd (Expected log predicitve density).

4. Check whether the estimated $\hat{l^1}$ is equal to or greater than that $l^1$ (the minimum lengthscale that can be accurately fitted determined by the $m^1$ and $c^1$ used).

5. If the verification in step 4 is TRUE, the HSGP model approximation must be sufficiently accurate, and diagnosis ends here. Otherwise, continue with the next step 6.

*Iteration 2*

6. Use the estimated lengthscale $\hat{l^1}$ to obtain the new $c^2$.

7. Repeat steps 1-5 and update parameters.

Note: In order to be a bit more conservative and make as less iterations as possible to get an accurate approximation, 5 or 10 basis functions can be added to the computed $m$ in each iteration.

## Fitting and diagnosis

Initializing programming objects:

```{r message=FALSE, warn=FALSE}
standata <- list()
fit <- list()
l_f1 <- vector()
c_f1 <- vector()
m_f1 <- vector()
l_f2 <- vector()
m_f2 <- vector()
l_f3 <- vector()
m_f3 <- vector()
l_f1_hat <- vector()
l_f2_hat <- vector()
l_f3_hat <- vector()
res <- list()
diagnosis <- list()
rmse <- vector()
eR2 <- vector()
elpd <- vector()
```

### Iteration 1

Iteration index

```{r message=FALSE, warn=FALSE}
i <- 1
```

#### Setting $m$, $l$ and $c$

**Smooth trend function $f_1$**

1. Making the first guess that the lengthscale $l$ might correspond to around 3 years (3*365=1095 days) of the input dimension

```{r message=FALSE, warn=FALSE}
l_f1[i] <- round(1095 / std_x, 2)
l_f1[i]
```

2. The boundary factor $c$ has to fulfill $c \, \geq \, 0.97 + 1.45 \, \frac{l}{S}$

```{r message=FALSE, warn=FALSE}
0.97 + 1.45*l_f1[i]/S
```

Then, $c$ is set to

```{r message=FALSE, warn=FALSE}
c_f1[i] <- 1.5
c_f1[i]
```

3. The number of basis functions $m$ as a function of $l$:  $\; m= 1.73 \, \frac{c}{(l/S)^{1.05}}$

```{r message=FALSE, warn=FALSE}
m_f1[i] <- ceiling(1.73 * c_f1[i]/(l_f1[i]/S)^1.05)
m_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Making the first guess that the lengthscale $l$ might corresponds to half of the period of $f_2$. So $l=0.5$

```{r message=FALSE, warn=FALSE}
l_f2[i] <- 0.5
l_f2[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
m_f2[i] <-  ceiling(3.31 * 1/l_f2[i]^1.05)
m_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Making the first guess that the lengthscale $l$ might corresponds to half of the period of $f_3$. So $l=0.5$

```{r message=FALSE, warn=FALSE}
l_f3[i] <- 0.5
l_f3[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
m_f3[i] <- ceiling(3.31 * 1/l_f3[i]^1.05)
m_f3[i]
```

#### Data to Stan

```{r message=FALSE, warn=FALSE}
standata[[i]] <- list(M_f1= m_f1[i], 
                         c_f1= c_f1[i], 
                         J_f2= m_f2[i], 
                         J_f3= m_f3[i], 
                         x= x[,1], 
                         y= y[,1], 
                         N= length(x), 
                         period_year= period_year, 
                         period_week= period_week,
                         day_of_year2= day_of_year2
)
str(standata[[i]])
```

#### Model fitting

Compiling the model

```{r message=FALSE, warn=TRUE, eval=FALSE}
# birthday_mod <- cmdstanr::cmdstan_model(stan_file = "stancode_def.stan")
```

Model sampling

```{r warn=TRUE, message=FALSE, eval=TRUE}
load("fit.rData")
```

```{r warn=TRUE, message=FALSE, eval=FALSE}
# fit[[i]] <- birthday_mod$sample(data= standata[[i]], iter_warmup=200, iter_sampling=200, chains=4, thin=4, init=0.5, adapt_delta=0.9, save_warmup=FALSE)
# fit[[i]] <- read_stan_csv(fit[[i]]$output_files())

# save(fit, file="fit.rData")
```

Summaries of variable estimates

```{r message=FALSE, warn=FALSE, eval=TRUE}
param = c("intercept","lscale[1]","lscale[2]","lscale[3]","gpscale[1]","gpscale[2]","gpscale[3]","noise","sigma_f4")
summary(fit[[i]], pars = param, probs = c(0.025, 0.5, 0.975), digits_summary = 4)$summary
```

Simulation chains for the variables after warmup

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE}
traceplot(fit[[i]], pars = param, include = TRUE, unconstrain = FALSE, inc_warmup = FALSE, window = NULL, nrow = NULL, ncol = NULL)
```

Plot of the mean posterior function $f_1$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
f <- summary(fit[[i]], pars = c("f"), probs = c(0.025, 0.5, 0.975))$summary
intercept <- summary(fit[[i]], pars = c("intercept"), probs = c(0.025, 0.5, 0.975))$summary
f1 <- summary(fit[[i]], pars = c("f1"), probs = c(0.025, 0.5, 0.975))$summary
f2 <- summary(fit[[i]], pars = c("f2"), probs = c(0.025, 0.5, 0.975))$summary
f3 <- summary(fit[[i]], pars = c("f3"), probs = c(0.025, 0.5, 0.975))$summary
f4 <- summary(fit[[i]], pars = c("f4"), probs = c(0.025, 0.5, 0.975))$summary
```

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

ind <- data$id
labels_at = aggregate(data, by=list(data$year), FUN=min)$id

obs_plt <- ((y[ind]-intercept[1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs_plt, type="p", pch=20, bg=grey(0.4), cex=0.6, col=grey(0.5), xlab="", ylab="", lwd=1, ylim=c(0.8,1.2), mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")

axis(1, at=labels_at, c("1969","1970","1971","1972","1973","1974","1975","1976","1977","1978","1979","1980","1981","1982","1983","1984","1985","1986","1987","1988"), tick=TRUE, lty=1, mgp=c(3, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Year", mgp=c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab="Proportion of births over the mean", mgp=c(3, 0.7, 0), cex.lab=1.6, las=1)

abline(h=1, lty=2)												                # mean
lines(ind, (f1[ind,1]*std_y+m_y)/m_y, col=2, lwd=2)				# f1

legend("topleft", inset=c(0.22,0.02), legend=c(TeX('Observations - intercept - $f_2$ - $f_3$ - $f_4$'),TeX('$f_1$')), col=c(grey(0.4),2,3,"grey"), lty=c(NA,1,1,1), pch=c(20,NA,NA,NA), lwd=c(1,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.5)
```

Plot of the mean posterior function $f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.85,1.15))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						        # mean
lines(ind, (f2[ind,1]*std_y+m_y)/m_y, col=3, lwd=2)	 		  # f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_3$ - $f_4$'),TeX('$f_2$')), col=c(grey(0.5),3), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the mean posterior function $f_1 + f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean
lines(ind, ((f1[ind,1]+f2[ind,1])*std_y+m_y)/m_y, col=4, lwd=2)	 		  # f1 + f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_3$ - $f_4$'),TeX('$f_1 + f_2$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the residuals

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_2$ - $f_3$ - $f_4$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

#### Model evaluation

Residuals

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
f <- summary(fit[[i]], pars = c("f"))$summary[,1]
res[[i]] <- standata[[i]]$y - f

ggplot(as.data.frame(res[[i]]), aes(res[[i]]))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Root mean squared error

```{r message=FALSE, warn=FALSE}
rmse[i] <- sqrt(mean(res[[i]]^2))
rmse[i]
```

Bayesian $R^2$ (Coefficient of determination)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
noise <- as.matrix(fit[[i]], pars = c("noise"))
sd_f <- apply(as.matrix(fit[[i]], pars = c("f")), 1, sd)
R2 <- sd_f^2/(sd_f^2 + noise^2)

ggplot(as.data.frame(R2), aes(R2))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of $R^2$

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
eR2[i] <- median(R2)
eR2[i]
```

Log predictive density (lpd)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
lpd <- summary(fit[[i]], pars = c("log_lik"))$summary[,1]

ggplot(as.data.frame(lpd), aes(lpd))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of lpd

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
elpd[i] <- median(lpd)
elpd[i]
```

#### Diagnosis

**Smooth trend function $f_1$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] <- round(summary(fit[[i]], pars = "lscale[1]")$summary[,1], 2)
l_f1_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f1` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] >= l_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] <- round(summary(fit[[i]], pars = "lscale[2]")$summary[,1], 2)
l_f2_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f2` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] >= l_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] <- round(summary(fit[[i]], pars = "lscale[3]")$summary[,1], 2)
l_f3_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f3` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] >= l_f3[i]
```

**Summary table**

```{r fig.height=3, fig.width=5, message=FALSE, warn=FALSE, echo=FALSE}
diagnosis[[i]] <- data.frame(iter= rep(i,3),
                                GP_func= c("f1", "f2", "f3"),
                                l= round(c(l_f1[i], l_f2[i], l_f3[i]),2),
                                c= round(c(c_f1[i], NA, NA), 2),
                                m= c(m_f1[i], m_f2[i], m_f3[i]),
                                l_hat= round(c(l_f1_hat[i], l_f2_hat[i], l_f3_hat[i]), 2),
                                'l_hat > l' = c(l_f1_hat[i] >= l_f1[i], l_f2_hat[i] >= l_f2[i], l_f3_hat[i] >= l_f3[i]),
                                rsme = round(rep(rmse[i],3), 3),
                                R2 = round(rep(eR2[i],3), 3),
                                elpd = round(rep(elpd[i],3), 3)
                                )
names(diagnosis[[i]]) <- c("iter", "GP_func", "l", "c", "m", "l_hat", "l_hat > l", "rmse", "R2", "elpd")
diagnosis[[i]]
```

### Iteration 2

Iteration index

```{r message=FALSE, warn=FALSE}
i <- 2
```

#### Setting $m$, $l$ and $c$

**Smooth trend function $f_1$**

1. Updating $l$ with its estimate $\hat{l}$ in the first iteration

```{r message=FALSE, warn=FALSE}
l_f1[i] <- l_f1_hat[i-1]
l_f1[i]
```

2. The boundary factor $c$ has to fulfill $c \, \geq \, 0.97 + 1.45 \, \frac{l}{S}$

```{r message=FALSE, warn=FALSE}
0.97 + 1.45*l_f1[i]/S
```

Then, $c$ is set to

```{r message=FALSE, warn=FALSE}
c_f1[i] <- 1.5
c_f1[i]
```

3. The number of basis functions $m$ as a function of $l$:  $\; m= 1.73 \, \frac{c}{(l/S)^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(1.73 * c_f1[i]/(l_f1[i]/S)^1.05 < 5) m_f1[i] <- 5 else m_f1[i] <- ceiling(1.73 * c_f1[i]/(l_f1[i]/S)^1.05)
m_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Updating $l$ with its estimate $\hat{l}$ in the first iteration

```{r message=FALSE, warn=FALSE}
l_f2[i] <- l_f2_hat[i-1]
l_f2[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f2[i]^1.05 < 5) m_f2[i] <- 5 else m_f2[i] <- ceiling( 3.31 * 1/l_f2[i]^1.05)
m_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Updating $l$ with its estimate $\hat{l}$ in the first iteration

```{r message=FALSE, warn=FALSE}
l_f3[i] <- l_f3_hat[i-1]
l_f3[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f3[i]^1.05 < 5) m_f3[i] <- 5 else m_f3[i] <- ceiling(3.31 * 1/l_f3[i]^1.05)
m_f3[i]
```

#### Data to Stan

```{r message=FALSE, warn=FALSE}
standata[[i]] <- list(M_f1= m_f1[i], 
                 c_f1= c_f1[i], 
                 J_f2= m_f2[i], 
                 J_f3= m_f3[i], 
                 x= x[,1], 
                 y= y[,1], 
                 N= length(x), 
                 period_year= period_year, 
                 period_week= period_week,
                 day_of_year2= day_of_year2
)
str(standata[[i]])
```

#### Model fitting

Compiling the model

```{r message=FALSE, warn=TRUE, eval=FALSE}
# birthday_mod <- cmdstanr::cmdstan_model(stan_file = "stancode_def.stan")
```

Model sampling (using `cmdstanr` package)

```{r message=FALSE, warn=FALSE, eval=TRUE}
# load("fit.rData")
```

```{r warn=TRUE, message=FALSE, eval=FALSE}
# fit[[i]] <- birthday_mod$sample(data= standata[[i]], iter_warmup=200, iter_sampling=200, chains=4, thin=4, init=0.5, adapt_delta=0.9, save_warmup=FALSE)
# fit[[i]] <- rstan::read_stan_csv(fit[[i]]$output_files())

# save(fit, file="fit.rData")
```

Summaries of variable estimates

```{r message=FALSE, warn=FALSE, eval=TRUE}
param = c("intercept","lscale[1]","lscale[2]","lscale[3]","gpscale[1]","gpscale[2]","gpscale[3]","noise","sigma_f4")
summary(fit[[i]], pars = param, probs = c(0.025, 0.5, 0.975), digits_summary = 4)$summary
```

Simulation chains for the variables after warmup

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE}
traceplot(fit[[i]], pars = param, include = TRUE, unconstrain = FALSE, inc_warmup = FALSE, window = NULL, nrow = NULL, ncol = NULL)
```

Plot of the mean posterior function $f_1$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
f <- summary(fit[[i]], pars = c("f"), probs = c(0.025, 0.5, 0.975))$summary
intercept <- summary(fit[[i]], pars = c("intercept"), probs = c(0.025, 0.5, 0.975))$summary
f1 <- summary(fit[[i]], pars = c("f1"), probs = c(0.025, 0.5, 0.975))$summary
f2 <- summary(fit[[i]], pars = c("f2"), probs = c(0.025, 0.5, 0.975))$summary
f3 <- summary(fit[[i]], pars = c("f3"), probs = c(0.025, 0.5, 0.975))$summary
f4 <- summary(fit[[i]], pars = c("f4"), probs = c(0.025, 0.5, 0.975))$summary
```

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

ind <- data$id
labels_at = aggregate(data, by=list(data$year), FUN=min)$id

obs_plt <- ((y[ind]-intercept[1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs_plt, type="p", pch=20, bg=grey(0.4), cex=0.6, col=grey(0.5), xlab="", ylab="", lwd=1, ylim=c(0.8,1.2), mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")

axis(1, at=labels_at, c("1969","1970","1971","1972","1973","1974","1975","1976","1977","1978","1979","1980","1981","1982","1983","1984","1985","1986","1987","1988"), tick=TRUE, lty=1, mgp=c(3, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Year", mgp=c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab="Proportion of births over the mean", mgp=c(3, 0.7, 0), cex.lab=1.6, las=1)

abline(h=1, lty=2)												                # mean
lines(ind, (f1[ind,1]*std_y+m_y)/m_y, col=2, lwd=2)				# f1

legend("topleft", inset=c(0.22,0.02), legend=c(TeX('Observations - intercept - $f_2$ - $f_3$ - $f_4$'),TeX('$f_1$')), col=c(grey(0.4),2,3,"grey"), lty=c(NA,1,1,1), pch=c(20,NA,NA,NA), lwd=c(1,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.5)
```

Plot of the mean posterior function $f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.85,1.15))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						        # mean
lines(ind, (f2[ind,1]*std_y+m_y)/m_y, col=3, lwd=2)	 		  # f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_3$ - $f_4$'),TeX('$f_2$')), col=c(grey(0.5),3), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the mean posterior function $f_1 + f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean
lines(ind, ((f1[ind,1]+f2[ind,1])*std_y+m_y)/m_y, col=4, lwd=2)	 		  # f1 + f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_3$ - $f_4$'),TeX('$f_1 + f_2$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the residuals

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_2$ - $f_3$ - $f_4$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

#### Model evaluation

Residuals

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
f <- summary(fit[[i]], pars = c("f"))$summary[,1]
res[[i]] <- standata[[i]]$y - f

ggplot(as.data.frame(res[[i]]), aes(res[[i]]))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Root mean squared error

```{r message=FALSE, warn=FALSE}
rmse[i] <- sqrt(mean(res[[i]]^2))
rmse[i]
```

Bayesian $R^2$ (Coefficient of determination)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
noise <- as.matrix(fit[[i]], pars = c("noise"))
sd_f <- apply(as.matrix(fit[[i]], pars = c("f")), 1, sd)
R2 <- sd_f^2/(sd_f^2 + noise^2)

ggplot(as.data.frame(R2), aes(R2))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of $R^2$

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
eR2[i] <- median(R2)
eR2[i]
```

Log predictive density (lpd)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
lpd <- summary(fit[[i]], pars = c("log_lik"))$summary[,1]

ggplot(as.data.frame(lpd), aes(lpd))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of lpd

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
elpd[i] <- median(lpd)
elpd[i]
```

#### Diagnosis

**Smooth trend function $f_1$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] <- round(summary(fit[[i]], pars = "lscale[1]")$summary[,1], 2)
l_f1_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f1` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] >= l_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] <- round(summary(fit[[i]], pars = "lscale[2]")$summary[,1], 2)
l_f2_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f2` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] >= l_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] <- round(summary(fit[[i]], pars = "lscale[3]")$summary[,1], 2)
l_f3_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f3` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] >= l_f3[i]
```

**Summary table**

```{r fig.height=3, fig.width=5, message=FALSE, warn=FALSE, echo=FALSE}
diagnosis[[i]] <- data.frame(iter= rep(i, 3),
                                 GP_func= c("f1", "f2", "f3"),
                                 l= round(c(l_f1[i], l_f2[i], l_f3[i]), 2),
                                 c= round(c(c_f1[i], NA, NA), 2),
                                 m= c(m_f1[i], m_f2[i], m_f3[i]),
                                 l_hat= round(c(l_f1_hat[i], l_f2_hat[i], l_f3_hat[i]), 2),
                                 'l_hat > l' = c(l_f1_hat[i] >= l_f1[i], l_f2_hat[i] >= l_f2[i], l_f3_hat[i] >= l_f3[i]),
                                 rsme = round(rep(rmse[i], 3), 3),
                                 R2 = round(rep(eR2[i], 3), 3),
                                 elpd = round(rep(elpd[i], 3), 3)
                                 )
names(diagnosis[[i]]) <- c("iter", "GP_func", "l", "c", "m", "l_hat", "l_hat > l", "rmse", "R2", "elpd")
diagnosis[[i]]
```


### Iteration 3

Iteration index

```{r message=FALSE, warn=FALSE}
i <- 3
```

#### Setting $m$, $l$ and $c$

**Smooth trend function $f_1$**

1. Updating $l$ with its estimate $\hat{l}$ in the second iteration

```{r message=FALSE, warn=FALSE}
l_f1[i] <- l_f1_hat[i-1]
l_f1[i]
```

2. The boundary factor $c$ has to fulfill $c \, \geq \, 0.97 + 1.45 \, \frac{l}{S}$

```{r message=FALSE, warn=FALSE}
0.97 + 1.45*l_f1[i]/S
```

Then, $c$ is set to

```{r message=FALSE, warn=FALSE}
c_f1[i] <- 1.5
c_f1[i]
```

3. The number of basis functions $m$ as a function of $l$:  $\; m= 1.73 \, \frac{c}{(l/S)^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(1.73 * c_f1[i]/(l_f1[i]/S)^1.05 < 5) m_f1[i] <- 5 else m_f1[i] <- ceiling(1.73 * c_f1[i]/(l_f1[i]/S)^1.05)
m_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Updating $l$ with its estimate $\hat{l}$ in the second iteration

```{r message=FALSE, warn=FALSE}
l_f2[i] <- l_f2_hat[i-1]
l_f2[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f2[i]^1.05 < 5) m_f2[i] <- 5 else m_f2[i] <- ceiling(3.31 * 1/l_f2[i]^1.05)
m_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Updating $l$ with its estimate $\hat{l}$ in the second iteration

```{r message=FALSE, warn=FALSE}
l_f3[i] <- l_f3_hat[i-1]
l_f3[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f3[i]^1.05 < 5) m_f3[i] <- 5 else m_f3[i] <- ceiling(3.31 * 1/l_f3[i]^1.05)
m_f3[i]
```

#### Data to Stan

```{r message=FALSE, warn=FALSE}
standata[[i]] <- list(M_f1= m_f1[i], 
                 c_f1= c_f1[i], 
                 J_f2= m_f2[i], 
                 J_f3= m_f3[i], 
                 x= x[,1], 
                 y= y[,1], 
                 N= length(x), 
                 period_year= period_year, 
                 period_week= period_week,
                 day_of_year2= day_of_year2
)
str(standata[[i]])
```

#### Model fitting

Compiling the model

```{r message=FALSE, warn=TRUE, eval=FALSE}
# birthday_mod <- cmdstanr::cmdstan_model(stan_file = "stancode_def.stan")
```

Model sampling

```{r message=FALSE, warn=FALSE, eval=TRUE}
# load("fit.rData")
```

```{r warn=TRUE, message=FALSE, eval=FALSE}
# fit[[i]] <- birthday_mod$sample(data= standata[[i]], iter_warmup=200, iter_sampling=200, chains=4, thin=4, init=0.5, adapt_delta=0.9, save_warmup=FALSE)
# fit[[i]] <- rstan::read_stan_csv(fit[[i]]$output_files())

# save(fit, file="fit.rData")
```

Summaries of variable estimates

```{r message=FALSE, warn=FALSE, eval=TRUE}
param = c("intercept","lscale[1]","lscale[2]","lscale[3]","gpscale[1]","gpscale[2]","gpscale[3]","noise","sigma_f4")
summary(fit[[i]], pars = param, probs = c(0.025, 0.5, 0.975), digits_summary = 4)$summary
```

Simulation chains for the variables after warmup

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE}
traceplot(fit[[i]], pars = param, include = TRUE, unconstrain = FALSE, inc_warmup = FALSE, window = NULL, nrow = NULL, ncol = NULL)
```

Plot of the mean posterior function $f_1$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
f <- summary(fit[[i]], pars = c("f"), probs = c(0.025, 0.5, 0.975))$summary
intercept <- summary(fit[[i]], pars = c("intercept"), probs = c(0.025, 0.5, 0.975))$summary
f1 <- summary(fit[[i]], pars = c("f1"), probs = c(0.025, 0.5, 0.975))$summary
f2 <- summary(fit[[i]], pars = c("f2"), probs = c(0.025, 0.5, 0.975))$summary
f3 <- summary(fit[[i]], pars = c("f3"), probs = c(0.025, 0.5, 0.975))$summary
f4 <- summary(fit[[i]], pars = c("f4"), probs = c(0.025, 0.5, 0.975))$summary
```

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

ind <- data$id
labels_at = aggregate(data, by=list(data$year), FUN=min)$id

obs_plt <- ((y[ind]-intercept[1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs_plt, type="p", pch=20, bg=grey(0.4), cex=0.6, col=grey(0.5), xlab="", ylab="", lwd=1, ylim=c(0.8,1.2), mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")

axis(1, at=labels_at, c("1969","1970","1971","1972","1973","1974","1975","1976","1977","1978","1979","1980","1981","1982","1983","1984","1985","1986","1987","1988"), tick=TRUE, lty=1, mgp=c(3, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Year", mgp=c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab="Proportion of births over the mean", mgp=c(3, 0.7, 0), cex.lab=1.6, las=1)

abline(h=1, lty=2)												                # mean
lines(ind, (f1[ind,1]*std_y+m_y)/m_y, col=2, lwd=2)				# f1

legend("topleft", inset=c(0.22,0.02), legend=c(TeX('Observations - intercept - $f_2$ - $f_3$ - $f_4$'),TeX('$f_1$')), col=c(grey(0.4),2,3,"grey"), lty=c(NA,1,1,1), pch=c(20,NA,NA,NA), lwd=c(1,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.5)
```

Plot of the mean posterior function $f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.85,1.15))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						        # mean
lines(ind, (f2[ind,1]*std_y+m_y)/m_y, col=3, lwd=2)	 		  # f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_3$ - $f_4$'),TeX('$f_2$')), col=c(grey(0.5),3), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the mean posterior function $f_1 + f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean
lines(ind, ((f1[ind,1]+f2[ind,1])*std_y+m_y)/m_y, col=4, lwd=2)	 		  # f1 + f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_3$ - $f_4$'),TeX('$f_1 + f_2$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the residuals

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_2$ - $f_3$ - $f_4$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

#### Model evaluation

Residuals

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
f <- summary(fit[[i]], pars = c("f"))$summary[,1]
res[[i]] <- standata[[i]]$y - f

ggplot(as.data.frame(res[[i]]), aes(res[[i]]))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Root mean squared error

```{r message=FALSE, warn=FALSE}
rmse[i] <- sqrt(mean(res[[i]]^2))
rmse[i]
```

Bayesian $R^2$ (Coefficient of determination)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
noise <- as.matrix(fit[[i]], pars = c("noise"))
sd_f <- apply(as.matrix(fit[[i]], pars = c("f")), 1, sd)
R2 <- sd_f^2/(sd_f^2 + noise^2)

ggplot(as.data.frame(R2), aes(R2))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of $R^2$

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
eR2[i] <- median(R2)
eR2[i]
```

Log predictive density (lpd)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
lpd <- summary(fit[[i]], pars = c("log_lik"))$summary[,1]

ggplot(as.data.frame(lpd), aes(lpd))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of lpd

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
elpd[i] <- median(lpd)
elpd[i]
```

#### Diagnosis

**Smooth trend function $f_1$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] <- round(summary(fit[[i]], pars = "lscale[1]")$summary[,1], 2)
l_f1_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f1` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] >= l_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] <- round(summary(fit[[i]], pars = "lscale[2]")$summary[,1], 2)
l_f2_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f2` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] >= l_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] <- round(summary(fit[[i]], pars = "lscale[3]")$summary[,1], 2)
l_f3_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f3` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] >= l_f3[i]
```

**Summary table**

```{r fig.height=3, fig.width=5, message=FALSE, warn=FALSE, echo=FALSE}
diagnosis[[i]] <- data.frame(iter= rep(i,3),
                                 GP_func= c("f1", "f2", "f3"),
                                 l= round(c(l_f1[i], l_f2[i], l_f3[i]), 2),
                                 c= round(c(c_f1[i], NA, NA), 2),
                                 m= c(m_f1[i], m_f2[i], m_f3[i]),
                                 l_hat= round(c(l_f1_hat[i], l_f2_hat[i], l_f3_hat[i]), 2),
                                 'l_hat > l' = c(l_f1_hat[i] >= l_f1[i], l_f2_hat[i] >= l_f2[i], l_f3_hat[i] >= l_f3[i]),
                                 rsme = round(rep(rmse[i], 3), 3),
                                 R2 = round(rep(eR2[i], 3), 3),
                                 elpd = round(rep(elpd[i], 3), 3)
                                 )
names(diagnosis[[i]]) <- c("iter", "GP_func", "l", "c", "m", "l_hat", "l_hat > l", "rmse", "R2", "elpd")
diagnosis[[i]]
```


### Iteration 4

Iteration index

```{r message=FALSE, warn=FALSE}
i <- 4
```

#### Setting $m$, $l$ and $c$

**Smooth trend function $f_1$**

1. Updating $l$ with its estimate $\hat{l}$ in the third iteration

```{r message=FALSE, warn=FALSE}
l_f1[i] <- l_f1_hat[i-1]
l_f1[i]
```

2. The boundary factor $c$ has to fulfill $c \, \geq \, 0.97 + 1.45 \, \frac{l}{S}$

```{r message=FALSE, warn=FALSE}
0.97 + 1.45*l_f1[i]/S
```

Then, $c$ is set to

```{r message=FALSE, warn=FALSE}
c_f1[i] <- 1.5
c_f1[i]
```

3. The number of basis functions $m$ as a function of $l$:  $\; m= 1.73 \, \frac{c}{(l/S)^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(1.73 * c_f1[i]/(l_f1[i]/S)^1.05 < 5) m_f1[i] <- 5 else m_f1[i] <- ceiling(1.73 * c_f1[i]/(l_f1[i]/S)^1.05)
m_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Updating $l$ with its estimate $\hat{l}$ in the third iteration

```{r message=FALSE, warn=FALSE}
l_f2[i] <- l_f2_hat[i-1]
l_f2[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f2[i]^1.05 < 5) m_f2[i] <- 5 else m_f2[i] <- ceiling(3.31 * 1/l_f2[i]^1.05)
m_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Updating $l$ with its estimate $\hat{l}$ in the third iteration

```{r message=FALSE, warn=FALSE}
l_f3[i] <- l_f3_hat[i-1]
l_f3[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f3[i]^1.05 < 5) m_f3[i] <- 5 else m_f3[i] <- ceiling(3.31 * 1/l_f3[i]^1.05)
m_f3[i]
```

#### Data to Stan

```{r message=FALSE, warn=FALSE}
standata[[i]] <- list(M_f1= m_f1[i], 
                 c_f1= c_f1[i], 
                 J_f2= m_f2[i], 
                 J_f3= m_f3[i], 
                 x= x[,1], 
                 y= y[,1], 
                 N= length(x), 
                 period_year= period_year, 
                 period_week= period_week,
                 day_of_year2= day_of_year2
)
str(standata[[i]])
```

#### Model fitting

Compiling the model

```{r message=FALSE, warn=TRUE, eval=FALSE}
# birthday_mod <- cmdstanr::cmdstan_model(stan_file = "stancode_def.stan")
```

Model sampling

```{r message=FALSE, warn=FALSE, eval=TRUE}
# load("fit.rData")
```

```{r warn=TRUE, message=FALSE, eval=FALSE}
# fit[[i]] <- birthday_mod$sample(data= standata[[i]], iter_warmup=200, iter_sampling=200, chains=4, thin=4, init=0.5, adapt_delta=0.9, save_warmup=FALSE)
# fit[[i]] <- rstan::read_stan_csv(fit[[i]]$output_files())

# save(fit, file="fit.rData")
```

Summaries of variable estimates

```{r message=FALSE, warn=FALSE, eval=TRUE}
param = c("intercept","lscale[1]","lscale[2]","lscale[3]","gpscale[1]","gpscale[2]","gpscale[3]","noise","sigma_f4")
summary(fit[[i]], pars = param, probs = c(0.025, 0.5, 0.975), digits_summary = 4)$summary
```

Simulation chains for the variables after warmup

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE}
traceplot(fit[[i]], pars = param, include = TRUE, unconstrain = FALSE, inc_warmup = FALSE, window = NULL, nrow = NULL, ncol = NULL)
```

Plot of the mean posterior function $f_1$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
f <- summary(fit[[i]], pars = c("f"), probs = c(0.025, 0.5, 0.975))$summary
intercept <- summary(fit[[i]], pars = c("intercept"), probs = c(0.025, 0.5, 0.975))$summary
f1 <- summary(fit[[i]], pars = c("f1"), probs = c(0.025, 0.5, 0.975))$summary
f2 <- summary(fit[[i]], pars = c("f2"), probs = c(0.025, 0.5, 0.975))$summary
f3 <- summary(fit[[i]], pars = c("f3"), probs = c(0.025, 0.5, 0.975))$summary
f4 <- summary(fit[[i]], pars = c("f4"), probs = c(0.025, 0.5, 0.975))$summary
```

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

ind <- data$id
labels_at = aggregate(data, by=list(data$year), FUN=min)$id

obs_plt <- ((y[ind]-intercept[1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs_plt, type="p", pch=20, bg=grey(0.4), cex=0.6, col=grey(0.5), xlab="", ylab="", lwd=1, ylim=c(0.8,1.2), mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")

axis(1, at=labels_at, c("1969","1970","1971","1972","1973","1974","1975","1976","1977","1978","1979","1980","1981","1982","1983","1984","1985","1986","1987","1988"), tick=TRUE, lty=1, mgp=c(3, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Year", mgp=c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab="Proportion of births over the mean", mgp=c(3, 0.7, 0), cex.lab=1.6, las=1)

abline(h=1, lty=2)												                # mean
lines(ind, (f1[ind,1]*std_y+m_y)/m_y, col=2, lwd=2)				# f1

legend("topleft", inset=c(0.22,0.02), legend=c(TeX('Observations - intercept - $f_2$ - $f_3$ - $f_4$'),TeX('$f_1$')), col=c(grey(0.4),2,3,"grey"), lty=c(NA,1,1,1), pch=c(20,NA,NA,NA), lwd=c(1,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.5)
```

Plot of the mean posterior function $f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.85,1.15))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						        # mean
lines(ind, (f2[ind,1]*std_y+m_y)/m_y, col=3, lwd=2)	 		  # f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_3$ - $f_4$'),TeX('$f_2$')), col=c(grey(0.5),3), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the mean posterior function $f_1 + f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean
lines(ind, ((f1[ind,1]+f2[ind,1])*std_y+m_y)/m_y, col=4, lwd=2)	 		  # f1 + f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_3$ - $f_4$'),TeX('$f_1 + f_2$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the residuals

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_2$ - $f_3$ - $f_4$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

#### Model evaluation

Residuals

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
f <- summary(fit[[i]], pars = c("f"))$summary[,1]
res[[i]] <- standata[[i]]$y - f

ggplot(as.data.frame(res[[i]]), aes(res[[i]]))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Root mean squared error

```{r message=FALSE, warn=FALSE}
rmse[i] <- sqrt(mean(res[[i]]^2))
rmse[i]
```

Bayesian $R^2$ (Coefficient of determination)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
noise <- as.matrix(fit[[i]], pars = c("noise"))
sd_f <- apply(as.matrix(fit[[i]], pars = c("f")), 1, sd)
R2 <- sd_f^2/(sd_f^2 + noise^2)

ggplot(as.data.frame(R2), aes(R2))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of $R^2$

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
eR2[i] <- median(R2)
eR2[i]
```

Log predictive density (lpd)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
lpd <- summary(fit[[i]], pars = c("log_lik"))$summary[,1]

ggplot(as.data.frame(lpd), aes(lpd))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of lpd

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
elpd[i] <- median(lpd)
elpd[i]
```

#### Diagnosis

**Smooth trend function $f_1$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] <- round(summary(fit[[i]], pars = "lscale[1]")$summary[,1], 2)
l_f1_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f1` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] >= l_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] <- round(summary(fit[[i]], pars = "lscale[2]")$summary[,1], 2)
l_f2_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f2` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] >= l_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] <- round(summary(fit[[i]], pars = "lscale[3]")$summary[,1], 2)
l_f3_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f3` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] >= l_f3[i]
```

**Summary table**

```{r fig.height=3, fig.width=5, message=FALSE, warn=FALSE, echo=FALSE}
diagnosis[[i]] <- data.frame(iter= rep(i,3),
                                 GP_func= c("f1","f2","f3"),
                                 l= round(c(l_f1[i],l_f2[i],l_f3[i]),2),
                                 c= round(c(c_f1[i],NA,NA),2),
                                 m= c(m_f1[i],m_f2[i],m_f3[i]),
                                 l_hat= round(c(l_f1_hat[i],l_f2_hat[i],l_f3_hat[i]),2),
                                 'l_hat > l' = c(l_f1_hat[i] >= l_f1[i],l_f2_hat[i] >= l_f2[i],l_f3_hat[i] >= l_f3[i]),
                                 rsme = round(rep(rmse[i],3),3),
                                 R2 = round(rep(eR2[i],3),3),
                                 elpd = round(rep(elpd[i],3),3)
                                 )
names(diagnosis[[i]]) <- c("iter", "GP_func", "l", "c", "m", "l_hat", "l_hat > l", "rmse", "R2", "elpd")
diagnosis[[i]]
```


### Iteration 5

Iteration index

```{r message=FALSE, warn=FALSE}
i <- 5
```

#### Setting $m$, $l$ and $c$

**Smooth trend function $f_1$**

1. Updating $l$ with its estimate $\hat{l}$ in the fourth iteration

```{r message=FALSE, warn=FALSE}
l_f1[i] <- l_f1_hat[i-1]
l_f1[i]
```

2. The boundary factor $c$ has to fulfill $c \, \geq \, 0.97 + 1.45 \, \frac{l}{S}$

```{r message=FALSE, warn=FALSE}
0.97 + 1.45*l_f1[i]/S
```

Then, $c$ is set to

```{r message=FALSE, warn=FALSE}
c_f1[i] <- 1.5
c_f1[i]
```

3. The number of basis functions $m$ as a function of $l$:  $\; m= 1.73 \, \frac{c}{(l/S)^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(1.73 * c_f1[i]/(l_f1[i]/S)^1.05 < 5) m_f1[i] <- 5 else m_f1[i] <- ceiling(1.73 * c_f1[i]/(l_f1[i]/S)^1.05)

m_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Updating $l$ with its estimate $\hat{l}$ in the third iteration

```{r message=FALSE, warn=FALSE}
l_f2[i] <- l_f2_hat[i-1]
l_f2[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f2[i]^1.05 < 5) m_f2[i] <- 5 else m_f2[i] <- ceiling(3.31 * 1/l_f2[i]^1.05);
m_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Updating $l$ with its estimate $\hat{l}$ in the fourth iteration

```{r message=FALSE, warn=FALSE}
l_f3[i] <- l_f3_hat[i-1]
l_f3[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\, m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f3[i]^1.05 < 5) m_f3[i] <- 5 else m_f3[i] <- ceiling(3.31 * 1/l_f3[i]^1.05)
m_f3[i]
```

#### Data to Stan

```{r message=FALSE, warn=FALSE}
standata[[i]] <- list(M_f1= m_f1[i], 
                 c_f1= c_f1[i], 
                 J_f2= m_f2[i], 
                 J_f3= m_f3[i], 
                 x= x[,1], 
                 y= y[,1], 
                 N= length(x), 
                 period_year= period_year, 
                 period_week= period_week,
                 day_of_year2= day_of_year2
)
str(standata[[i]])
```

#### Model fitting

Compiling the model

```{r message=FALSE, warn=TRUE, eval=FALSE}
# birthday_mod <- cmdstanr::cmdstan_model(stan_file = "stancode_def.stan")
```

Model sampling

```{r message=FALSE, warn=FALSE, eval=TRUE}
# load("fit.rData")
```

```{r warn=TRUE, message=FALSE, eval=FALSE}
# fit[[i]] <- birthday_mod$sample(data= standata[[i]], iter_warmup=200, iter_sampling=200, chains=4, thin=4, init=0.5, adapt_delta=0.9, save_warmup=FALSE)
# fit[[i]] <- rstan::read_stan_csv(fit[[i]]$output_files())

# save(fit, file="fit.rData")
```

Summaries of variable estimates

```{r message=FALSE, warn=FALSE, eval=TRUE}
param = c("intercept","lscale[1]","lscale[2]","lscale[3]","gpscale[1]","gpscale[2]","gpscale[3]","noise","sigma_f4")
summary(fit[[i]], pars = param, probs = c(0.025, 0.5, 0.975), digits_summary = 4)$summary
```

Simulation chains for the variables after warmup

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE}
traceplot(fit[[i]], pars = param, include = TRUE, unconstrain = FALSE, inc_warmup = FALSE, window = NULL, nrow = NULL, ncol = NULL)
```

Plot of the mean posterior function $f_1$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
f <- summary(fit[[i]], pars = c("f"), probs = c(0.025, 0.5, 0.975))$summary
intercept <- summary(fit[[i]], pars = c("intercept"), probs = c(0.025, 0.5, 0.975))$summary
f1 <- summary(fit[[i]], pars = c("f1"), probs = c(0.025, 0.5, 0.975))$summary
f2 <- summary(fit[[i]], pars = c("f2"), probs = c(0.025, 0.5, 0.975))$summary
f3 <- summary(fit[[i]], pars = c("f3"), probs = c(0.025, 0.5, 0.975))$summary
f4 <- summary(fit[[i]], pars = c("f4"), probs = c(0.025, 0.5, 0.975))$summary
```

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

ind <- data$id
labels_at = aggregate(data, by=list(data$year), FUN=min)$id

obs_plt <- ((y[ind]-intercept[1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs_plt, type="p", pch=20, bg=grey(0.4), cex=0.6, col=grey(0.5), xlab="", ylab="", lwd=1, ylim=c(0.8,1.2), mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")

axis(1, at=labels_at, c("1969","1970","1971","1972","1973","1974","1975","1976","1977","1978","1979","1980","1981","1982","1983","1984","1985","1986","1987","1988"), tick=TRUE, lty=1, mgp=c(3, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Year", mgp=c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab="Proportion of births over the mean", mgp=c(3, 0.7, 0), cex.lab=1.6, las=1)

abline(h=1, lty=2)												                # mean
lines(ind, (f1[ind,1]*std_y+m_y)/m_y, col=2, lwd=2)				# f1

legend("topleft", inset=c(0.22,0.02), legend=c(TeX('Observations - intercept - $f_2$ - $f_3$ - $f_4$'),TeX('$f_1$')), col=c(grey(0.4),2,3,"grey"), lty=c(NA,1,1,1), pch=c(20,NA,NA,NA), lwd=c(1,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.5)
```

Plot of the mean posterior function $f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.85,1.15))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						        # mean
lines(ind, (f2[ind,1]*std_y+m_y)/m_y, col=3, lwd=2)	 		  # f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_3$ - $f_4$'),TeX('$f_2$')), col=c(grey(0.5),3), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the mean posterior function $f_1 + f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean
lines(ind, ((f1[ind,1]+f2[ind,1])*std_y+m_y)/m_y, col=4, lwd=2)	 		  # f1 + f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_3$ - $f_4$'),TeX('$f_1 + f_2$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the residuals

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_2$ - $f_3$ - $f_4$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

#### Model evaluation

Residuals

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
f <- summary(fit[[i]], pars = c("f"))$summary[,1]
res[[i]] <- standata[[i]]$y - f

ggplot(as.data.frame(res[[i]]), aes(res[[i]]))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Root mean squared error

```{r message=FALSE, warn=FALSE}
rmse[i] <- sqrt(mean(res[[i]]^2))
rmse[i]
```

Bayesian $R^2$ (Coefficient of determination)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
noise <- as.matrix(fit[[i]], pars = c("noise"))
sd_f <- apply(as.matrix(fit[[i]], pars = c("f")), 1, sd)
R2 <- sd_f^2/(sd_f^2 + noise^2)

ggplot(as.data.frame(R2), aes(R2))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of $R^2$

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
eR2[i] <- median(R2)
eR2[i]
```

Log predictive density (lpd)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
lpd <- summary(fit[[i]], pars = c("log_lik"))$summary[,1]

ggplot(as.data.frame(lpd), aes(lpd))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of lpd

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
elpd[i] <- median(lpd)
elpd[i]
```

#### Diagnosis

**Smooth trend function $f_1$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] <- round(summary(fit[[i]], pars = "lscale[1]")$summary[,1], 2)
l_f1_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f1` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] >= l_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] <- round(summary(fit[[i]], pars = "lscale[2]")$summary[,1], 2)
l_f2_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f2` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] >= l_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] <- round(summary(fit[[i]], pars = "lscale[3]")$summary[,1], 2)
l_f3_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f3` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] >= l_f3[i]
```

**Summary table**

```{r fig.height=3, fig.width=5, message=FALSE, warn=FALSE, echo=FALSE}
diagnosis[[i]] <- data.frame(iter= rep(i,3),
                                 GP_func= c("f1","f2","f3"),
                                 l= round(c(l_f1[i],l_f2[i],l_f3[i]),2),
                                 c= round(c(c_f1[i],NA,NA),2),
                                 m= c(m_f1[i],m_f2[i],m_f3[i]),
                                 l_hat= round(c(l_f1_hat[i],l_f2_hat[i],l_f3_hat[i]),2),
                                 'l_hat > l' = c(l_f1_hat[i] >= l_f1[i],l_f2_hat[i] >= l_f2[i],l_f3_hat[i] >= l_f3[i]),
                                 rsme = round(rep(rmse[i],3),3),
                                 R2 = round(rep(eR2[i],3),3),
                                 elpd = round(rep(elpd[i],3),3)
                                 )
names(diagnosis[[i]]) <- c("iter", "GP_func", "l", "c", "m", "l_hat", "l_hat > l", "rmse", "R2", "elpd")
diagnosis[[i]]
```

### Iteration 6

Iteration index

```{r message=FALSE, warn=FALSE}
i <- 6
```

#### Setting $m$, $l$ and $c$

**Smooth trend function $f_1$**

1. Updating $l$ with its estimate $\hat{l}$ in the fifth iteration

```{r message=FALSE, warn=FALSE}
l_f1[i] <- l_f1_hat[i-1]
l_f1[i]
```

2. The boundary factor $c$ has to fulfill $c \, \geq \, 0.97 + 1.45 \, \frac{l}{S}$

```{r message=FALSE, warn=FALSE}
0.97 + 1.45*l_f1[i]/S
```

Then, $c$ is set to

```{r message=FALSE, warn=FALSE}
c_f1[i] <- 1.5
c_f1[i]
```

3. The number of basis functions $m$ as a function of $l$:  $\; m= 1.73 \, \frac{c}{(l/S)^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(1.73 * c_f1[i]/(l_f1[i]/S)^1.05 < 5) m_f1[i] <- 5 else m_f1[i] <- ceiling(1.73 * c_f1[i]/(l_f1[i]/S)^1.05)
m_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Updating $l$ with its estimate $\hat{l}$ in the fifth iteration

```{r message=FALSE, warn=FALSE}
l_f2[i] <- l_f2_hat[i-1]
l_f2[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f2[i]^1.05 < 5) m_f2[i] <- 5 else m_f2[i] <- ceiling(3.31 * 1/l_f2[i]^1.05)
m_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Updating $l$ with its estimate $\hat{l}$ in the fifth iteration

```{r message=FALSE, warn=FALSE}
l_f3[i] <- l_f3_hat[i-1]
l_f3[i]
```

2. Number of basis functions $m$ as a function of $l$:  $\; m= 3.31 \, \frac{1}{l^{1.05}}$

```{r message=FALSE, warn=FALSE}
if(3.31 * 1/l_f3[i]^1.05 < 5) m_f3[i] <- 5 else m_f3[i] <- ceiling(3.31 * 1/l_f3[i]^1.05)
m_f3[i]
```

#### Data to Stan

```{r message=FALSE, warn=FALSE}
standata[[i]] <- list(M_f1= m_f1[i], 
                 c_f1= c_f1[i], 
                 J_f2= m_f2[i], 
                 J_f3= m_f3[i], 
                 x= x[,1], 
                 y= y[,1], 
                 N= length(x), 
                 period_year= period_year, 
                 period_week= period_week,
                 day_of_year2= day_of_year2
)
str(standata[[i]])
```

#### Model fitting

Compiling the model

```{r message=FALSE, warn=TRUE, eval=FALSE}
# birthday_mod <- cmdstanr::cmdstan_model(stan_file = "stancode_def.stan")
```

Model sampling

```{r message=FALSE, warn=FALSE, eval=TRUE}
# load("fit.rData")
```

```{r warn=TRUE, message=FALSE, eval=FALSE}
# fit[[i]] <- birthday_mod$sample(data= standata[[i]], iter_warmup=200, iter_sampling=200, chains=4, thin=4, init=0.5, adapt_delta=0.9, save_warmup=FALSE)
# fit[[i]] <- rstan::read_stan_csv(fit[[i]]$output_files())

# save(fit, file="fit.rData")
```

Summaries of variable estimates

```{r message=FALSE, warn=FALSE, eval=TRUE}
param = c("intercept","lscale[1]","lscale[2]","lscale[3]","gpscale[1]","gpscale[2]","gpscale[3]","noise","sigma_f4")
summary(fit[[i]], pars = param, probs = c(0.025, 0.5, 0.975), digits_summary = 4)$summary
```

Simulation chains for the variables after warmup

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE}
traceplot(fit[[i]], pars = param, include = TRUE, unconstrain = FALSE, inc_warmup = FALSE, window = NULL, nrow = NULL, ncol = NULL)
```

Plot of the mean posterior function $f_1$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
f <- summary(fit[[i]], pars = c("f"), probs = c(0.025, 0.5, 0.975))$summary
intercept <- summary(fit[[i]], pars = c("intercept"), probs = c(0.025, 0.5, 0.975))$summary
f1 <- summary(fit[[i]], pars = c("f1"), probs = c(0.025, 0.5, 0.975))$summary
f2 <- summary(fit[[i]], pars = c("f2"), probs = c(0.025, 0.5, 0.975))$summary
f3 <- summary(fit[[i]], pars = c("f3"), probs = c(0.025, 0.5, 0.975))$summary
f4 <- summary(fit[[i]], pars = c("f4"), probs = c(0.025, 0.5, 0.975))$summary
```

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, fig.align='center', eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

ind <- data$id
labels_at = aggregate(data, by=list(data$year), FUN=min)$id

obs_plt <- ((y[ind]-intercept[1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs_plt, type="p", pch=20, bg=grey(0.4), cex=0.6, col=grey(0.5), xlab="", ylab="", lwd=1, ylim=c(0.8,1.2), mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")

axis(1, at=labels_at, c("1969","1970","1971","1972","1973","1974","1975","1976","1977","1978","1979","1980","1981","1982","1983","1984","1985","1986","1987","1988"), tick=TRUE, lty=1, mgp=c(3, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Year", mgp=c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab="Proportion of births over the mean", mgp=c(3, 0.7, 0), cex.lab=1.6, las=1)

abline(h=1, lty=2)												                # mean
lines(ind, (f1[ind,1]*std_y+m_y)/m_y, col=2, lwd=2)				# f1

legend("topleft", inset=c(0.22,0.02), legend=c(TeX('Observations - intercept - $f_2$ - $f_3$ - $f_4$'),TeX('$f_1$')), col=c(grey(0.4),2,3,"grey"), lty=c(NA,1,1,1), pch=c(20,NA,NA,NA), lwd=c(1,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.5)
```

Plot of the mean posterior function $f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.85,1.15))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						        # mean
lines(ind, (f2[ind,1]*std_y+m_y)/m_y, col=3, lwd=2)	 		  # f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_3$ - $f_4$'),TeX('$f_2$')), col=c(grey(0.5),3), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the mean posterior function $f_1 + f_2$

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean
lines(ind, ((f1[ind,1]+f2[ind,1])*std_y+m_y)/m_y, col=4, lwd=2)	 		  # f1 + f2

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_3$ - $f_4$'),TeX('$f_1 + f_2$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

Plot of the residuals

```{r message=FALSE, warn=FALSE, fig.height=7, fig.width=15, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year %in% seq(1969,1981,1),]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

obs <- ((y[ind]-intercept[1]-f1[ind,1]-f2[ind,1]-f3[ind,1]-f4[data$day_of_year2,1][ind])*std_y+m_y)/m_y
plot(ind, obs, type="p", lty=1, pch=20, cex=0.6, col=grey(0.5), xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.8,1.2))

axis(1, at=axis_labels_at, labels=as.character(seq(1969,1981,1)), tick=TRUE, cex.axis=1.6)

lines(range(ind), c(1,1), lty=2, lwd=1)						                    # mean

abline(v=axis_labels_at, lty=2, col=grey(0.7))
legend("topleft", inset=c(0.05,0.005), legend=c(TeX('Observations - intercept - $f_1$ - $f_2$ - $f_3$ - $f_4$')), col=c(grey(0.5),4), lty=c(NA,1), pch=c(20,NA), lwd=c(3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.3)
```

#### Model evaluation

Residuals

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
f <- summary(fit[[i]], pars = c("f"))$summary[,1]
res[[i]] <- standata[[i]]$y - f

ggplot(as.data.frame(res[[i]]), aes(res[[i]]))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Root mean squared error

```{r message=FALSE, warn=FALSE}
rmse[i] <- sqrt(mean(res[[i]]^2))
rmse[i]
```

Bayesian $R^2$ (Coefficient of determination)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
noise <- as.matrix(fit[[i]], pars = c("noise"))
sd_f <- apply(as.matrix(fit[[i]], pars = c("f")), 1, sd)
R2 <- sd_f^2/(sd_f^2 + noise^2)

ggplot(as.data.frame(R2), aes(R2))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of $R^2$

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
eR2[i] <- median(R2)
eR2[i]
```

Log predictive density (lpd)

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
lpd <- summary(fit[[i]], pars = c("log_lik"))$summary[,1]

ggplot(as.data.frame(lpd), aes(lpd))  +
  geom_histogram(color = 'white') +
  theme_classic()
```

Median of lpd

```{r fig.height=2, fig.width=4, message=FALSE, warn=FALSE}
elpd[i] <- median(lpd)
elpd[i]
```

#### Diagnosis

**Smooth trend function $f_1$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] <- round(summary(fit[[i]], pars = "lscale[1]")$summary[,1], 2)
l_f1_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f1` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f1_hat[i] >= l_f1[i]
```

**Yearly periodic effects function $f_2$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] <- round(summary(fit[[i]], pars = "lscale[2]")$summary[,1], 2)
l_f2_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f2` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f2_hat[i] >= l_f2[i]
```

**Weekly periodic effects function $f_3$**

1. Estimated lengthscale $\hat{l}$  

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] <- round(summary(fit[[i]], pars = "lscale[3]")$summary[,1], 2)
l_f3_hat[i]
```

2. Check whether $\hat{l}$ is equal to or greater than `l_f3` (the minimum $l$ that can be accurately fitted determined by the $m$ used)

```{r message=FALSE, warn=FALSE}
l_f3_hat[i] >= l_f3[i]
```

**Summary table**

```{r fig.height=3, fig.width=5, message=FALSE, warn=FALSE, echo=FALSE}
diagnosis[[i]] <- data.frame(iter= rep(i,3),
                                 GP_func= c("f1","f2","f3"),
                                 l= round(c(l_f1[i],l_f2[i],l_f3[i]),2),
                                 c= round(c(c_f1[i],NA,NA),2),
                                 m= c(m_f1[i],m_f2[i],m_f3[i]),
                                 l_hat= round(c(l_f1_hat[i],l_f2_hat[i],l_f3_hat[i]),2),
                                 'l_hat > l' = c(l_f1_hat[i] >= l_f1[i],l_f2_hat[i] >= l_f2[i],l_f3_hat[i] >= l_f3[i]),
                                 rsme = round(rep(rmse[i],3),3),
                                 R2 = round(rep(eR2[i],3),3),
                                 elpd = round(rep(elpd[i],3),3)
                                )
names(diagnosis[[i]]) <- c("iter", "GP_func", "l", "c", "m", "l_hat", "l_hat > l", "rmse", "R2", "elpd")
diagnosis[[i]]
```

### Global summary of the diagnosis (with all iterations)

```{r fig.height=3, fig.width=5, message=FALSE, warn=FALSE, echo=FALSE}
diagnosis_summ <- rbind(diagnosis[[1]],diagnosis[[2]],diagnosis[[3]],diagnosis[[4]],diagnosis[[5]],diagnosis[[6]])

diagnosis_summ[diagnosis_summ$GP_func=="f1",]
diagnosis_summ[diagnosis_summ$GP_func=="f2",]
diagnosis_summ[diagnosis_summ$GP_func=="f3",]
```

## Plots of the mean posterior functions from the last iteration

Extracting estimated function components $f_1$, $f_2$, $f_3$ and $f_4$

```{r message=FALSE, warn=FALSE, eval=TRUE}
f <- summary(fit[[i]], pars = c("f"), probs = c(0.025, 0.5, 0.975))$summary
intercept <- summary(fit[[i]], pars = c("intercept"), probs = c(0.025, 0.5, 0.975))$summary
f1 <- summary(fit[[i]], pars = c("f1"), probs = c(0.025, 0.5, 0.975))$summary
f2 <- summary(fit[[i]], pars = c("f2"), probs = c(0.025, 0.5, 0.975))$summary
f3 <- summary(fit[[i]], pars = c("f3"), probs = c(0.025, 0.5, 0.975))$summary
f4 <- summary(fit[[i]], pars = c("f4"), probs = c(0.025, 0.5, 0.975))$summary
```

#### Plot of only one year, the year 1972 

```{r message=FALSE, warn=FALSE, fig.height=8, fig.width=14, eval=TRUE, echo=FALSE}
data_year <- data[data$year==1972,]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$month), FUN=min)$id

par(mai=c(1, 0.82, 0.1, 0.42))

plot(ind, (y[ind]*std_y+m_y)/m_y, type="p", pch=21, bg=grey(0.7), cex=0.9, col=grey(0.4), xlab="", ylab="", lwd=1, ylim=c(0.73,1.16), mgp= c(2, 1, 0), frame.plot = TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")
axis(1, at=axis_labels_at, labels=c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"), tick=TRUE, lty=1, mgp=c(2, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab ="Month", mgp= c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab ="Proportion of births over the mean", mgp= c(3, 0.7, 0), cex.lab=1.6, las=1)
	
lines(ind, ((f[ind,1]+intercept[1])*std_y+m_y)/m_y, col=grey(0.6), lwd=1)	    # f
abline(h=1, lty=2)						                                                # mean
lines(ind, ((f1[ind,1]+intercept[1])*std_y+m_y)/m_y, col=2, lwd=2)			      # f1 
lines(ind, ((f1[ind,1]+intercept[1]+f2[ind,1])*std_y+m_y)/m_y, col=3, lwd=2)	# f1 + f2 
lines(ind, (f4[data$day_of_year2,1][ind]*std_y+m_y)/m_y, col=6, lwd=1) 		    # f4 

#labels special days
text(ind[data_year$month==1&data_year$day==1]+2, y = 0.84, labels = "New year", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==2&data_year$day==14], y = 1.045, labels = "Valentine's day", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==2&data_year$day==29], y = 0.978, labels = "Leap day", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==4&data_year$day==1]+2, y = 0.980, labels = "April 1st", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==5&data_year$day==27], y = 0.98, labels = "Memorial day", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==7&data_year$day==4], y = 0.86, labels = "Independence day", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==9&data_year$day==2], y = 0.97, labels = "Labor day", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==10&data_year$day==30]+2, y = 0.985, labels = "Halloween", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==11&data_year$day==25]+5, y = 0.95, labels = "Thanks-giving", pos =NULL, offset = 0, family="serif", cex=1.3)
text(ind[data_year$month==12&data_year$day==25], y = 0.82, labels = "Christmas", pos =NULL, offset = 0, family="serif", cex=1.3)

legend("topleft", inset=c(0.05,0.01), legend=c("Observations",TeX('$f_1$'),TeX('$f_1 + f_2$'),TeX('$f_4$'),TeX('$f_1 + f_2 + f_3 + f_4$')), col=c(grey(0.5),2,3,6,grey(0.5)), lty=c(NA,1,1,1,1), pch=c(20,NA,NA,NA,NA), lwd=c(2,3,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=2, seg.len=1.3)
```


#### Plot of all the years

```{r message=FALSE, warn=FALSE, fig.height=8, fig.width=14, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

ind <- data$id
labels_at = aggregate(data, by=list(data$year), FUN=min)$id
plot(ind, (y[ind]*std_y+m_y)/m_y, type="p", pch=20, bg=grey(0.4), cex=0.6, col=grey(0.5), xlab="", ylab="", lwd=1, ylim=c(0.7,1.3), mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n", fg=grey(0.5), family="serif")

axis(1, at=labels_at, c("1969","1970","1971","1972","1973","1974","1975","1976","1977","1978","1979","1980","1981","1982","1983","1984","1985","1986","1987","1988"), tick=TRUE, lty=1, mgp=c(3, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Year", mgp=c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab="Proportion of births over the mean", mgp=c(3, 0.7, 0), cex.lab=1.6, las=1)

abline(h=1, lty=2)												                                        # mean
lines(ind, ((f1[ind,1]+intercept[1])*std_y+m_y)/m_y, col=2, lwd=2)				        # f1
lines(ind, ((f1[ind,1]+intercept[1]+f2[ind,1])*std_y+m_y)/m_y, col=3, lwd=2)			# f1 + f2

legend("topleft", inset=c(0.22,0.02), legend=c("Observations",TeX('$f_1$'),TeX('$f_1 + f_2$')), col=c(grey(0.4),2,3,"grey"), lty=c(NA,1,1,1), pch=c(20,NA,NA,NA), lwd=c(1,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=1, seg.len=1.5)
```

#### Plot of only the first month 

```{r message=FALSE, warn=FALSE, fig.height=8, fig.width=14, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_month <- data[data$month==1&data$year==1972,]
ind <- data_month$id
axis_labels_at <- aggregate(data_month, by=list(data_month$day), FUN=min)$id

id_week <- data_month$id[data_month$day_of_week==1]

plot(ind, (y[ind]*std_y+m_y)/m_y, type="p", pch=21, bg=grey(0.7), cex=1.2, col=grey(0.4), xlab="", ylab="", lwd=1, ylim=c(0.7,1.2), mgp=c(3.5, 1, 0), frame.plot=TRUE, yaxs="r", cex.axis=1.6, cex.lab=1.6, las=1, xaxt="n", yaxt="n",fg=grey(0.5), family="serif")

axis(1, at=axis_labels_at[c(1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31)], labels=as.character(1:31)[c(1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31)], tick=TRUE, lty=1, mgp=c(3, 1, 0), las=1, cex.axis=1.6, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(1, at=id_week, labels=rep(c("Monday"),5), tick=TRUE, lty=1, mgp=c(-1, -1.2, 0), las=1, cex.axis=1.3, font=1, col=grey(0.5), col.ticks=grey(0.3), family="")
axis(2, at=NULL, labels=TRUE, tick=TRUE, lty=1, mgp=c(3, 0.7, 0), las=1, cex.axis=1.6, font=5, col=grey(0.5), col.ticks=grey(0.3))
title(xlab="Day", mgp=c(3, 1, 0), cex.lab=1.6, las=1)
title(ylab="Proportion of births over the mean", mgp=c(3, 0.7, 0), cex.lab=1.6, las=1)

lines(ind, ((f[ind,1]+intercept[1])*std_y+m_y)/m_y, col="black", lwd=3)                 	# f
abline(h=1, lty=2)											                                                  # mean
lines(ind, ((intercept[1]+f1[ind,1])*std_y+m_y)/m_y, col=2, lwd=3)			                  # f1 
lines(ind, ((intercept[1]+f1[ind,1]+f2[ind,1])*std_y+m_y)/m_y, col=3, lwd=3)	 		        # f1 + f2
lines(ind, (f3[ind,1]*std_y+m_y)/m_y, col=4, lwd=2)	 	                # f3
lines(ind, (f4[data$day_of_year2,1][ind]*std_y+m_y)/m_y, col=6, lwd=2) 		                # f4 

abline(v=id_week, lty=2, col="grey")

#labels special days
text(ind[data_month$month==1&data_month$day==1]-0.05, y = 0.84, labels = "New year", pos =NULL, offset = 0, family="serif", cex=1.3, xpd=TRUE,)

legend("topleft", inset=c(0.107,0.005), legend=c("Observations",TeX('$f_1$'),TeX('$f_1 + f_2$'),TeX('$f_3$'),TeX('$f_4$'),TeX('$f_1 + f_2 + f_3 + f_4$')), col=c(grey(0.5),2,3,4,6,"black"), lty=c(NA,1,1,1,1,1), pch=c(20,NA,NA,NA,NA,NA), lwd=c(3,3,3,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=2, seg.len=1.3)
```

#### Plot of the first four years

```{r message=FALSE, warn=FALSE, fig.height=8, fig.width=14, eval=TRUE, echo=FALSE}
par(mai=c(1, 0.82, 0.1, 0.42))

data_year <- data[data$year==1969 | data$year==1970 | data$year==1971 | data$year==1972,]
ind <- data_year$id
axis_labels_at <- aggregate(data_year, by=list(data_year$year), FUN=min)$id

plot(ind, (y[ind]*std_y+m_y)/m_y, type="p", lty=1, pch=18, cex=0.4, col="black", xlab="", ylab="Proportion of births over the mean", cex.lab=1.5, cex.axis=1.6, xaxt="n", ylim=c(0.7,1.3))

axis(1, at=axis_labels_at, labels=c("1969","1970","1971","1972"), tick=TRUE, cex.axis=1.6)

lines(ind, ((f[ind,1]+intercept[1])*std_y+m_y)/m_y, col="grey", lwd=1)		    # f
lines(range(ind), c(1,1), lty=2, lwd=2)						                            # mean
lines(ind, ((intercept[1]+f1[ind,1])*std_y+m_y)/m_y, col=2, lwd=1)			      # f1
lines(ind, ((intercept[1]+f1[ind,1]+f2[ind,1])*std_y+m_y)/m_y, col=3, lwd=3)	# f1 + f2
lines(ind, (f4[data$day_of_year2,1][ind]*std_y+m_y)/m_y, col=6, lwd=1) 		    # f4

legend("topleft", inset=c(0.05,0.005), legend=c("Observations",TeX('$f_1$'),TeX('$f_1 + f_2$'),TeX('$f_4$'),TeX('$f_1 + f_2 + f_3 + f_4$')), col=c(grey(0.5),2,3,6,"grey"), lty=c(NA,1,1,1,1), pch=c(20,NA,NA,NA,NA), lwd=c(3,3,3,3,3), cex=1.4, xpd=TRUE, bty="n", y.intersp=1, x.intersp=0.8, text.font=1, ncol=2, seg.len=1.3)
```



